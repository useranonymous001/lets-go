ðŸ§  Level 1: Core Concurrency & Synchronizationâœ… 
1. Safe Counter with Mutex
Create a counter that can be safely incremented by 100 goroutines. Each goroutine should increment the counter 1000 times.

âœ… Use sync.Mutex
âœ… Print the final count (should be 100000)

2. Bank Account Simulationâœ… 
Simulate a bank account where multiple goroutines deposit and withdraw money.

Protect shared balance with mutex.

Ensure that a withdrawal doesn't happen if balance is insufficient.

âœ… Use condition variable to wait for sufficient balance before withdrawing
âœ… Prevent race conditions on balance

3. Producer-Consumer (Bounded Buffer)âœ… 
Implement a producer-consumer system using a fixed-size slice (buffer).

Producer adds items to buffer.

Consumer removes items.

If buffer is full, producer waits.

If buffer is empty, consumer waits.

âœ… Use sync.Mutex + sync.Cond
âœ… Simulate multiple producers and consumers

ðŸ§  Level 2: Coordination & Wait Groups
4. Wait for N Workers to Finishâœ… 
Spin off 10 goroutines that do some "work" (e.g., sleep + print). The main goroutine should wait until all of them are done before exiting.

âœ… Use sync.WaitGroup
âœ… Learn how Add, Done, and Wait work

5. One-Time Initialization (Once)âœ… 
Use sync.Once to initialize a configuration (e.g., load from file). Simulate 10 goroutines trying to access the config â€” only one should trigger the load function.

âœ… Use sync.Once
âœ… Confirm config load message prints once

ðŸ§  Level 3: Realistic Coordination Challenges
6. Reader-Writer Lockâœ… 
Simulate multiple readers and writers on a shared log buffer.

Multiple readers can read at once.

Only one writer can write at a time.

No reader can read while writing is in progress.

âœ… Use sync.RWMutex
âœ… Show how reads and writes interleave safely

7. Traffic Light Controllerâœ… 
You have 3 lanes: red, yellow, green. Only one can be active at a time.

Change light every 2 seconds in a loop.

Multiple goroutines may be waiting for green to proceed.

Ensure only green allows passing.

âœ… Use sync.Cond for coordination
âœ… Use shared state to represent the current light

ðŸ§  Level 4: Simulate System-like Behavior
8. Elevator Controller
Simulate an elevator system:

5 floors

Goroutines simulate passengers requesting floors
Elevator moves between floors, picking up and dropping off
Handle concurrent requests without deadlocks

âœ… Use mutexes and condition variables to model movement and wait logic

9. Thread Pool / Worker Pool
Implement a thread pool with:

A fixed number of workers

A job queue (channel)

Each job is a function that prints something or sleeps

âœ… Use buffered channel for jobs
âœ… Goroutines as workers
âœ… Use sync.WaitGroup to know when all jobs are done

10. Ping Pong Game (Goroutine Sync)
Two goroutines print "Ping" and "Pong" alternately 100 times.

âœ… Use 2 channels or 1 condition variable to sync alternation
âœ… Print: Ping, Pong, Ping, ...

ðŸ§© Bonus Challenge (Advanced Coordination)
11. Deadlock Detector Simulation
Simulate 2 goroutines locking two resources (mutexes) in reverse order. Demonstrate how deadlock happens. Then fix it by ordering the locks.

âœ… Learn ordering discipline to avoid deadlocks

